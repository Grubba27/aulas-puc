{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["import fs from 'fs/promises';\nasync function main () {\n  const FILE = await fs.readFile('./aula-01.txt', {encoding: 'utf-8'});\n  const fileWithLines = FILE.split(\"\\n\");\n  const [numOps, ...file] = fileWithLines;\n\n  type Divider = (list: string[], quantity: number) => string[][];\n  const divider: Divider = (list, quantity) =>\n    list.reduce<string[][]>((accumulator, item, index) => {\n      const chunkIndex = Math.floor(index / quantity)\n\n      if (!accumulator[chunkIndex]) {\n        accumulator[chunkIndex] = []\n      }\n\n      accumulator[chunkIndex].push(item)\n      return accumulator\n    }, []);\n\n  const divided = divider(file, 3);\n\n  type GetUniqueItems = (conj1: string, conj2: string) => string[];\n  const getUniqueItems: GetUniqueItems = (conj1, conj2) =>\n    [...new Set(`${conj1},${conj2}`.split(\",\"))]\n\n  type GetUnique = (conj: string) => string[];\n  const getUnique: GetUnique = (conj) =>\n    [...new Set(conj.split(\",\"))]\n\n  type Union = (conj1: string, conj2: string) => string;\n  const union: Union = (conj1, conj2) =>\n    getUniqueItems(conj1, conj2)\n      .join(\",\");\n\n  type Intersection = (conj1: string, conj2: string) => string;\n  const intersection: Intersection = (conj1, conj2) =>\n    getUniqueItems(conj1, conj2)\n      .filter(item => conj1.includes(item) && conj2.includes(item))\n      .join(\",\");\n\n\n  type Difference = (conj1: string, conj2: string) => string;\n  const difference: Difference = (conj1, conj2) =>\n    getUniqueItems(conj1, conj2)\n      .filter(item => !conj2.includes(item))\n      .join(\",\");\n\n  type CartesianProduct = (conj1: string, conj2: string) => string[][];\n  const cartesianProduct: CartesianProduct = (conj1, conj2) =>\n    getUnique(conj1)\n      .map(item1 => getUnique(conj2)\n        .map(item2 => `${item1},${item2}`))\n\n  const format =\n    (conj1: string, conj2: string) =>\n      (operation: string, result: string) =>\n        console.log(`${operation}: conjunto 1 {${conj1}}, conjunto 2 {${conj2}}. Resultado: {${result}} \\n`);\n\n  Array.from(Array(Number(numOps)).keys()).map((item) => {\n    const [op, conj1, conj2] = divided[item];\n    const logger = format(conj1, conj2);\n    switch (op) {\n      case \"U\":\n        return logger('Uni\u00E3o', union(conj1, conj2));\n\n      case \"I\":\n        return logger('Interce\u00E7\u00E3o', intersection(conj1, conj2));\n\n      case \"D\":\n        return logger('Diferen\u00E7a', difference(conj1, conj2));\n\n      case \"C\":\n        return logger('Produto Cartesiano', JSON.stringify(cartesianProduct(conj1, conj2)));\n    }\n  })\n}\n\nmain();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA,sBAAe;AACf,sBAAuB;AACrB,QAAM,OAAO,MAAM,wBAAG,SAAS,iBAAiB,EAAC,UAAU;AAC3D,QAAM,gBAAgB,KAAK,MAAM;AACjC,QAAM,CAAC,WAAW,QAAQ;AAG1B,QAAM,UAAmB,CAAC,MAAM,aAC9B,KAAK,OAAmB,CAAC,aAAa,MAAM,UAAU;AACpD,UAAM,aAAa,KAAK,MAAM,QAAQ;AAEtC,QAAI,CAAC,YAAY,aAAa;AAC5B,kBAAY,cAAc;AAAA;AAG5B,gBAAY,YAAY,KAAK;AAC7B,WAAO;AAAA,KACN;AAEL,QAAM,UAAU,QAAQ,MAAM;AAG9B,QAAM,iBAAiC,CAAC,OAAO,UAC7C,CAAC,GAAG,IAAI,IAAI,GAAG,SAAS,QAAQ,MAAM;AAGxC,QAAM,YAAuB,CAAC,SAC5B,CAAC,GAAG,IAAI,IAAI,KAAK,MAAM;AAGzB,QAAM,QAAe,CAAC,OAAO,UAC3B,eAAe,OAAO,OACnB,KAAK;AAGV,QAAM,eAA6B,CAAC,OAAO,UACzC,eAAe,OAAO,OACnB,OAAO,UAAQ,MAAM,SAAS,SAAS,MAAM,SAAS,OACtD,KAAK;AAIV,QAAM,aAAyB,CAAC,OAAO,UACrC,eAAe,OAAO,OACnB,OAAO,UAAQ,CAAC,MAAM,SAAS,OAC/B,KAAK;AAGV,QAAM,mBAAqC,CAAC,OAAO,UACjD,UAAU,OACP,IAAI,WAAS,UAAU,OACrB,IAAI,WAAS,GAAG,SAAS;AAEhC,QAAM,SACJ,CAAC,OAAe,UACd,CAAC,WAAmB,WAClB,QAAQ,IAAI,GAAG,0BAA0B,uBAAuB,uBAAuB;AAAA;AAE7F,QAAM,KAAK,MAAM,OAAO,SAAS,QAAQ,IAAI,CAAC,SAAS;AACrD,UAAM,CAAC,IAAI,OAAO,SAAS,QAAQ;AACnC,UAAM,SAAS,OAAO,OAAO;AAC7B,YAAQ;AAAA,WACD;AACH,eAAO,OAAO,YAAS,MAAM,OAAO;AAAA,WAEjC;AACH,eAAO,OAAO,oBAAc,aAAa,OAAO;AAAA,WAE7C;AACH,eAAO,OAAO,gBAAa,WAAW,OAAO;AAAA,WAE1C;AACH,eAAO,OAAO,sBAAsB,KAAK,UAAU,iBAAiB,OAAO;AAAA;AAAA;AAAA;AAKnF;",
  "names": []
}
